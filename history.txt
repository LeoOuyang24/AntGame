This document keeps track of all changes as well as considered changes made to the resources as well as why they were made. Consider this a "learning from the past" kind of document. 

1/2/2020:
	ResourceComponent now has all the functionality of ResourceCountComponent and ResourceCountComponent has been deleted. There is simply no reason to have both of these components. ResourceCountComponent not only kept track of the amount of resources like a ResourceComponent but also rendered the amount. Fusing these two classes will standardize things and allow more than just ants to collect resources.
	ApproachComponent::setTarget(const std::shared_ptr&) has now been changed to accept a non-const pointer. This is a small change; it's made so that setTarget can be called on ApproachComponent's findNearest function without having to test if findNearest returned null

12/19/2019:
	ApproachComponent's setTarget member functions now takes in const references to std::shared_ptr rather than just a reference. This allows us to use std::shared_ptr<Ant> in place of std::shared_ptr<Unit>, since having a const reference allows us to take an r-value, in this case the conversion of std::shared_ptr<Ant> to std::shared_ptr<Unit>.

12/18/2019:
	I considered removing the vector<std::shared_ptr<Component>> components variable in the Entity class because we already have all the components attached to an entity stored in Component Containers. However, searching through every component container would be difficult. I kept the vector to make updating an entity easier.
	Created ApproachComponent, which is a MoveComponent that can move towards a target Unit. It keeps track of this target unit with a weak ptr. It is essentially a more flexible MoveComponent; if the targetUnit pointer is null, this class behaves exactly like a MoveComponent. Why not instead add the functionality directly to MoveComponent? MoveComponent is in components.h, which means that it should work with all entities, whereas ApproachComponent is only supposed to work with Unit. I considered having MoveComponent hold a weak_ptr to a RectComponent but there's currently no way to get a shared_ptr to a component.

12/17/2019:
	AntManager now has an enum that represents all the possible tasks the manager can be currently working on. Currently, they are IDLE, ATTACK, MOVE, and COLLECT. IDLE means the manager is not doing anything at the moment and the ants are just standing around. While it is possible to deduce what the AntManager is currently doing based on the values of various member variables, this solution is a bit cleaner and easier to manage.
	The game now quits if the anthill is destroyed. The way this is done is currently kind of gritty. The Gamewindow has a public boolean variable called quit that represents whether or not the game should quit. The main loop checks the value of this quit value every iteration and quits if it is ever true.

12/8/2019:
	Both Manager::addEntity and Manager::addAnt now return a shared_ptr to the unit/ant added. This allows other classes that also want to share ownership to copy the pointer. So far, this is only used by the anthill class to create a weak_ptr to ants that it owns. 
	Anthill currently directly has a list of std::weak_ptr<Ant> to keep track of what ants are associated with it rather than a component that keeps track of the ants. This may be changed later.
	Anthill now directly creates ants. Pressing the create ant button now instead causes the anthill to create an ant. This is a built-in Anthill feature; Anthill directly does this rather than relying on a component. Feel free to change this. 

12/5/2019:
	Manager's RawQuadTree member variable was changed from a RawQuadTree to a regular QuadTree. This change was reverted because the RawQuadTree keeps track of RectComponents, not the actual units. Since it doesn't own the components, it doesn't make sense to use QuadTree.
	AntManager is now no longer considered to be a singleton class like Manager, but a class that represents all the tasks various groups of ants are working on. One change is that the class now manages a raw pointer to its creating Manager. This is a raw pointer because the pointer is only alive as long as either the Manager is; if the Manager is ever null, the AntManager should also be destroyed. It should be noted that Manager still has a singleton shared_ptr to AntManager. It'll be changed to a vector of AntManagers at a later more convenient time.
	AntManager's targetUnit member variable was changed from a Unit* to a std::weak_ptr<Unit>. A weak_ptr is now used to prevent dangling memory. Since there are now supposed to be multiple instances of AntManager, having a raw pointer to a target unit that is manually handled becomes more expensive, so a weak_ptr makes things easier.-
	AntManager is now a public friend class outside of Manager. There is clearly a lot of variables inside Manager that AntManager wants to access. The question was whether or not to keep AntManager inside Manager and if so, should it be public or private? Private nesting was overturned because other classes may need pointers to AntManager, most notably Ant since each Ant may need to point to its owning AntManager. This may change in the future. Public Nesting was overturned because there's no reason to have public nesting since the only change is that the name of AntManager's member functions in game.cpp are now longer. May as well move AntManager out and make it a friend class to create less typing.
	The spacing variable inside Manager has now been moved to AntManager. Since AntManager is the class that controls ant positioning, the variable makes more since in AntManager.
	Manager now no longer has a master vector of entities, but rather a master map of entities, where the key is the address of the entity. This was primarily done to make accessing entities, particularly when testing collision easier. The RawQuadTree only has raw pointers to the RectComponent within each Unit; if a class, such as say AntManager, wants to maintain a weak_ptr to an entity, it would need to copy the original shared_ptr. This mapping allows one to quickly find collision detection with a RectComponent, then quickly find not only the actual Unit the RectComponent stands for, but also the shared_ptr to copy.
	Having a RawQuadTree of actual Units may make things easier than having a RawQuadTree of RectComponents. This way, the RawQuadTree could become a regular QuadTree and actually own each object, which will make copying into a weak_ptr easier. However, then Unit would have to inherit from either RectPositional or RectComponent. In either case, making Units that have different movement/collision patterns is awkward as that would cause a lot of inheritance from Unit. One point of the component system is to prevent our actual Units from inheriting as changes to the base class (in this case Unit) causes a waterfall of changes. 


	