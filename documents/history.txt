This document keeps track of considered changes made to the resources as well as why they were made. Consider this a "learning from the past" kind of document. 

3/12/2021:
	Changed previous decision about how assembled objects should always function even if the assembler is destroyed. Things like ProjectileAssembler require the parent assembler to still be functional for things like the projectile. 

3/11/2021:
	UnitAnimationComponent now no longer keeps a pointer to a UnitAnimationSet because doing so caused things to break if the assembler ever was destroyed. Assembled objects should always function even if the ObjectAssembler is destroyed. (Removed 3/12/2021)

3/9/2021:	
	Decided to temporarily abandon AntsGame for a simpler roguelike to help Mia with her college apps and to release a simpler game for my first game.

3/1/2021:
	Added tempArmor to the HealthComponent to help in keeping track of armor. By simply adding and subtracting from armor, we run into the issue that we have to reset armor to 0 at some point but because some components that wnat to modify it occur before HealthComponent::update() and some occur after, it's not easy setting armor to 0 and not overwrite any armor increases or decreases. Temp armor serves as a counter of all the armor modifications. While it does mean that any armor modifications will not take place until HealthComponent::update, this is only applicable for the first frame that an armor modification is made and only applicable to damage dealt before the update called which is a small enough deficit for us to overlook.

2/27/2021:
	Panel::updateBlit now no longer affects mousePos at all. It is simply impossible to calculate mousePos without knowing about the camera before hand. An alternative function could take in the camera and translate accordingly but that doesn't work either because Panels are unaware of if itself is absolute or not. A second updateBlit takes care of this. Panel::updateBlit(2) takes in a camera and a bool on whether or not to render absolute or not. This allows better translation of mousePos.
	Decision to have Panel::updateBlit take in a function that returns a rect and translate mousePos was decided against because the fact that lambdas that capture variables can't be passed in as function pointers makes it difficult to do basic translations that don't involve static variables. For example, [](glm::vec4 rect){return blit;} is impossible because this lambda has to capture blit unless blit is global.

2/18/2021:
	Some class exclusive components in friendlyAssemblers no longer inherit from componentContainer because the only reason we do that, is to ensure that it can be retrieved via getComponent. Since private components can only even be referenced by members of the class that they are private to, it's unlikely that they will ever be retrieved by getComponent, and as a slight performance boost, we don't bother adding them to ComponentContainer.
	AttackComponent has a new struct called AttackData, which stores modifiable data like range, damage, and endLag (inverse of attack speed). This is mainly to help keep track of modified vs base data. While we could have two copies of the data for base and modified, this eliminates some typing. For example, if we want to reset our custom data, we could just set modData = baseData rather than individually setting every member. This is also more flexible for when we add more data that can be modified.

2/14/2021: 
	Panel's updateBlit now modifies mousePos based on the blit rect for convenience. updateBlit purposely doesn't take in a mousePos as a parameter because it's supposed to handle it. This will ensure that it will handle it correctly. (REVOKED: 2/27/2021)

2/4/2021:
	After much work, the grouping behavior in Ants Game has been pushed. It's not perfect but should suffice for now. It currently sets all ants to the same point and all ants independently move towards it. Ants will stop once they arrived at their destination or, more likely, bumped into another ant that's arrived and the current ant is within a certain distance of the destination. This distance is the maximum distance from the destination that ants that have reached the destination have reached. Since ants can be pushed, this distance may be quite far and only grows as more ants reach the destination. Without this additional condition, ant groups will stop immediately after one ant reaches the destination, which while fine, means that in large groups, most ants won't be very close to the target at all. This solution isn't perfect, but it does improve it somewhat.

1/4/2021:
	Code::blocks has long had an issue with files named "sprite". Old projects with sprite.h didn't work and sprite.cpp in Ants Game has alwyas had massive lag spikes when we swap to the file. Today, I deleted the file and replaced it with animation.cpp to go with animation.h. This has fixed the lag tremendously for some reason.

1/3/2021: 
	A unit's list of status effects is currently tracked in the HealthComponent. It could be tracked in any component, including separate component altogether. Currently, the HealthComponent renders the healthbar and since the effects will be rendered along with the health bar, it is currently stored in HealthComponent.
	StatusEffect currently has a seemingly random value member variable. This is because most status effects can be described using 4 things: duration, an icon, a function that describes how the effect works, and a value variable that generally shows how strong the effect is. For example, the value may represent how much the entity is slowed or how much damage they take over time. By declaring this seemingly arbitrary variable, we create a very flexible situation where most effects can be declared without ever declaring a new version of the update function.

1/2/2021:
	RenderCamera has been added as a universal camera class to render.h. This decision makes sense since cameras exist in all games, not just Ant Game. It also allows us to finally use camera functions in the base render.h functions.

12/26/2020:
	ProjectileComponent's new shooter variable currenlty can only be set through a setter function and not through the constructor. This is simply because right now, we don't need the constructor to do that; we should be okay with adding this later if necessary.

12/10/2020:
	Changed AnimationComponent to take in a reference to an animation rather than a pointer because it makes more sense. We never want to pass a null animation to the component and in the off chance that we have a AnimationWrapper* const variable, we want to be able to dereference the pointer to pass the animation to the component while making the pointer const. Basically, we care more about the AnimationWrapper than the pointer, so we pass by reference.
	Tentative change that changed all Unit and ObjectAssembler member variables to public and const. These variables will never change and are effectively static; may as well make them public for cleanliness and also removes the need for getter functions. We can't make assemblers aggregates because: 
	1. The constructor of aggregates is how we added assemblers to different buckets.
	2. We literally can't lol: the assemble function is a virtual member function. 

11/17/2020:
	Big glInterface changes have been made. Windows and Buttons are now Panels, which can be added to windows. Panels have an update function that takes in a mouse position, z, and a scale rect, which is a glm::vec4 where the x,y is a displacement for the rect and the dimensions are the scaling dimensions. The reason for having the users explicitly pass the mouse position is so that they can decide how to calculate the mouse position, since in some cases, such as when the camera zooms in, the mouse position can be calculated in different ways. We could have them just pass in the scale rect and then we calculate the mouse position explicitly but this gives us a bit more flexibility. Honestly, I'm just too lazy to improve on it, since every change causes such a large cascade of changes.

10/8/2020:
	Decided to make the world map a separate Window rather than the same window as Game Window. While having 2 windows means we now need to faciliate communication between the 2, it also means that we can stay a bit more organized. We are almost certainly going to have to create a WorldMapWindow regardless, the question is purely if we want to have interface own the window or GameWindow to own the window.

9/7/2020:
	Added 2 optimizations to pathfinding algorithm. When a new best distance is found, we don't have to update the heap. We also now keep a set of visited nodes so we don't go from Node A to B then back to A.

8/29/2020:
	Decided against using an std::map in place of MinHeap in the pathfinding algorithm because the map sorts by using keys rather than values. You can't store distance as the keys and the points as the nodes either because you have to be able to update the distances.

8/6/2020:
	Removed ShootComponent and instead added attacking from a distance to AttackComponent. Making melee attacks is essentially a ranged attack with a range of 0, so it doesn't make sense to have 2 different components when one is all that's needed.

8/5/2020:
	For some reason, even though ApproachComponent::findNearestUnit<T>() is a templated function, implementing it in a .cpp file has worked fine until today, presumably because the only function that uses it is ResourceEatComponent::update, which is also in entities.cpp. Today, another file needed the function, which triggered an "undefined reference" error. Putting findNearestUnit<T>() to the header file didn't fix this as the function refers to GameWindow, but #include "game.h" in entities.h causes a circular dependency. I also tried to move the function to a .tpp file, but this did nothing as I still had to do #include "entities.tpp" in the .h file, which is basically the same thing as putting the function in entities.h file but with extra steps. Since the problem is the reference to GameWindow, the function now takes in an extra parameter, which is the RawQuadTree to search on. This eliminates any mention of GameWindow in entities.h until another templated function screws everything up. 

7/29/2020:
	Encountered an issue with the assembler paradigm. Because Units and Objects are so deeply integrated into our code, we have to use them. In the future, it may be more convenient to only use Entities, since they are so much more flexible. The problem with Unit and Objects stems from the original reason for their creation, which was the observation that all objects in our game have to have certain components, such as a position component (RectComponent), a sprite (RenderComponent), and can be clicked on (ClickableComponent). In order to ensure that these objects will always have these components, these objects' constructors required these components to be provided. Problem is, we are now moving to the assembler design which has the benefit of giving us the stats of an object without actually having to create an object. When creating an object through an assembler, the assembler takes the stats and slaps it on an object. The question is what components to use. Spawning ants may have a different ClickableComponent than an enemy. The easiest solution is to do something like this : 

	Object* obj = new Object(*(new RectComponent(*obj)));

Problem is components also need to know about their owners in their constructors. This code as a result doesn't work because obj is null at this time. 
3 solutions have been put forth:
	1. Components can be created and their owners can then be added afterward via a addEntity() function. 
	Why this doesn't work: This is an attractive solution on the surface but because of how Components and all of their parents need to each individually record their owners in ComponentContainer, this is actually somewhat annoying. Constructors allow Components to pass data to ComponentContainers through the inheritance hierarchy with little issue. addEntity() could hypothetically have the same functionality but every time a new Component is made, we'd have to make a new addEntity function that looks like this: 
	ComponentContainer::remove();
	ParentComponent::addEntity();
	ComponentContainer::insert();

This can get annoying although it is doable.
	2. Have all Objects have the same basic 3 components.
	Why this doesn't work: This is another very clean solution. It's unlikely that an object will ever need anything other than AnimationComponent or PathComponent. Even if another object needed a different component, we could do something like ApproachComponent, which is not a MoveComponent but a component that affects a MoveComponent. In fact, we could probably simulate every MoveComponent replacement component with a MoveComponent influencer component. Still, it's risky as it's possible that we may need an object in the future that needs something completely different.
	3. Allow Objects to add essential components after construction. 
	Why we chose this solution: This solution is very clean and gives a lot of flexibility. The biggest issue with it is that Objects.getRect() doesn't always return a valid RectComponent. However, this is probably not a big deal since only Assemblers will be calling the blank constructor.

7/25/2020:
	Decided against giving Chunks private members and getters. Even though Chunks are getting more complicated, most of the interaction with outside classes is still done through the Map class. As a result, Chunk will remain an extension of the Map class rather than an independent class.

7/17/2020:
	There are currently two ways to render Polygons in Ants game: translate the point and then render it with PolyRender or pass a raw point to GameWindow which then translates the point before passing it to PolyRender. Essentially, it's a question of whether or not the point should be translated before being passed to a RenderComponent's render function or after. The answer used to always be "after"; we'd take whatever screen point we wanted to render something to and pass it to a RenderComponent, which would pass it to GameWindow which would handle translating the point to the right spot. Our reliance on GameWindow to render everything is show with GameWindow::renderAbsolute, which exists so whenever we called GameWindow::requestNGon/requestRect, we'd know whether or not to render it in an absolute spot or in spot relative to the camera without additional parameters. With AnimationComponents in the game, it is more obvious the flaw with this approach, which is that we need to write a GameWindow equivalent of AnimationWrapper::request. In fact, we would need to write a GameWindow equivalent to every request function, including PolyRender::requestLine and FontWrapper::requestWrite. The truth is, all the Gamewindow render functions do are translate a point and then pass it onto the equivalent render.h function. It would save time if we just translated the point beforehand by using the GameWindow camera and then passing the point to the render.h function ourselves. Essentially, we're getting rid fo the middle man that is GameWindow. The most notable function that will still use GameWindow render functions is renderMeter. renderMeter is a strange function in the sense that it already knows the height of the rect at all times but this height is somewhat inaccurate because of camera zoom and how sometimes we want to render the rect in an absolute position. Having GameWindow handle all makes life easier.

7/12/2020:
	AnimationParameter is now a separate class from SpriteParameter and Animation requests now consist of both a Sprite Parameter and Animation Parameter. This just makes life easier because otherwise, AnimationParameter would just be one bit struct that requires you to set all the SpriteParameter values before setting the Animation Parameter values. Dividing them makes it easier and it makes sense since Animations are literally just collections of sprites. The SpriteParameter is about how to render the frame and the AnimationParameter is about which frame to render.	
	Added a new constructor to Object and Unit. This new constructor instead takes in arguments for the rectComponent, RenderComponent, and HealthComponent rather than a component. This forces the constructor to construct the components which is safer because as it ensures the entity will be initialized by the time the components are created.
Example: Object* obj = new Object(*(new RectComponent({1,1,1,1},*obj))); 
This is unsafe as obj hasn't been initialized yet. 
	Decided against having Entity::addComponent() take in a pointer rather than a reference. The argument passed into addComponent should always be a heap object which may imply that the argument should take in a pointer but we only want non-null pointers, where it makes more sense to take in a reference. While this means that taking in a reference to a locally allocated object will cause an error, so too will taking in a pointer to a locally allocated object. Both methods can cause an error, but taking in a reference shows that the argument can't be null.

7/11/2020:
	Created an entity assembler class that returns an Entity with certain components attached. The idea here is to create a "blueprint" of objects so that we can check things about entities without actually having to create an entity. For example, if I were making an object that is always 64x64, I could find this out by looking at an object's assmebler and not have to actually create the object. If I were to then create the object, I'd call the assembler's assemble method. Currently, the assemble method returns an entity on the heap. The reason we do this instead of taking in an entity and adding components is because classes like Object and Structure expect the object to already have certain components at construction. We can't create an empty Object and then pass it into the assembler. In hindsight, this may be a better approach but we already have too much built around the idea of Object and Structure to change it. 

7/10/2020:
	Created a new Player class that keeps track of player inputs (selecting, building units) as well as resources and money. This class, like Manager and Camera, can be a static class where everything is a static method of variable. In case we ever decide to add multiplayer, and in keeping with the tradition of having GameWindow fetch all global classes, Player is not a static class. This makes it so that Player isn't the "odd one out" class that is static while everything else isn't. 

6/20/2020:
	AttackComponents are now now children of ApproachComponents because they share very similar properties: both attempt to move towards a target if it is nearby and both do nothing if there are no targets. In fact, attackcomponents are effictively ApproachComponents that also deal damage while in range and can only target objects with health bars.

5/31/2020:
	NavMeshNodes originally had a vector of all of its neighbors and then a vector of vectors for neighbors from each direction. This was an organization technique to make finding a specific neighbor faster. This has now been replaced with a unordered_map<NavMeshNode*, glm::vec4> where the pointer is the neighbor and the vec4 is the intersecting line. This map finds neighbors in logarithmic time which will always be generally faster than a vector. We could combine the two solutions to have a vector of maps to further organize the maps based on position. I feel like this is unncessary especially that means that something like searching for a certain neighbor will have to be done with a for loop through all the maps. This creates unnecessarily long code for a marginally faster computation time. Keep in mind that this also means that adding a node will take longer.

5/30/2020:
	NavMeshNode has a vector of vectors where each index represents one set of neighbors. This was done instead of having 4 separate vectors because we can iterate through all neighbors with one for loop rather than 4. 

5/25/2020:
	Chunks no longer differentiate between ants and units and store them all into one vector. There's simply know reason to keep them separate as they share many of the same behaviours, notably that they each need to be updated and the moved in the quadtree. Any behaviour specific to ants can be specified by checking if a unit has an AntMoveComponent. The one issue is that now ants are rendered underneath anthills but that may not be an issue since in the future, they won't overlap anyway as they will have their own hitboxes.

5/21/2020:
	Rewrote how antmanagers store child tasks. AntManagers themselves no longer store their children; rather Managers will have a tree of tasks and their child tasks. This makes a lot more sense because Managers need to know about a task and its children while AntManagers only interact with their children when splitting. AntManager::smartThis has been removed as it is no longer needed.

5/14/2020:
	Decided to not remove the parentTask pointer in Manager because the parentTask isn't always the same as the currentTask's parent. (ie: when we split, the current task is still the old current task but the parentTask is now also the current task.)
	Changed AntManager::smartThis from a smart pointer to a weak pointer. The reason for this is because upon deleting an AntManager, it's smart pointer would still exist and would prevent the object from being deleted. A weak pointer fixes this problem but now AntManagers must now take a shared_ptr of themselves into their constructor so they can initialize smartThis.
5/4/2020:
	The ability to move ants in the opposite direction of the selected point has been removed. I don't think this feature will be used as ants moving away from a point is kind of niche. It was originally used to allow ants to dodge attacks but it's more effective to just move away from them. The feature still technically exists but doesn't do anything; it may be added in later.
	Added a member variable called smartThis to AntManager. This is an interesting concept; it's a shared_ptr of the "this" pointer, meaning every AntManager has a smart pointer pointing to themselves. This is actually very useful, as we now always know where the smart pointer of a particular AntManager is stored. This can be seen in the split function, where an AntManager must pass itself to its children.

4/7/2020:
	Because the UI needs to render selected entities onto a set point of the screen but the entities also need to be rendered onto their correct spot on the world, many functions that render objects had to take in a parameter to determine whether to render in an absolute position or to a world position. This is cluncky because we'd have to rewrite every render function with an additional boolean parameter. The truth is, every render function follows a pattern: if it's called when rendering world stuff, it's rendered to the world position and if it's called when rendering UI stuff, it's rendered in an absolute position. If that's the case, we can just create a static boolean variable that determines whether or not something is rendered to the world or to the absolute based on what we are currently rendering. We already have the GameWindow::update function divided into such functions so adding this boolean variable is simple. We'll call it  GameWindow::renderAbsolute. All we have to do now is ensure that every render call is a GameWindow render call, such as GameWindow::requestNGon. As of now, GameWindow::requestNGon and GameWindow::requestRect still allow entities to choose to render absolute if they so choose. This bool will override a false GameWindow::renderAbsolute. You can think of it as:
	if (bool || renderAbsolute) 
	{
		renderAbsolute();
	}

4/6/2020:
	The new Label instances can now be turned on/off via the new Trigger class. The Trigger base class consists of a constructor and a single member function that returns false. Children of the Trigger class will return true/false based on their own functionality; the LambTrigger, for example, will return according to a lambda. The motivation behind the Trigger class, rather than just having Label take in two lambdas, is to be able to combine two different types of triggers. If we just had two lambdas, we'd have to specify the type of the lambdas; if they required parameters, we'd have to specify them at compile time. Trigger encapsulates the lambdas and allows us to mix and match triggers for each label. 
	Why not:
		Use templated lambdas to pass in different types of lambdas?
		Problem with this is that sometimes we also need to catch local variables and templates don't allow us to do that. 
		
		Use std::function?
		Std::function would probably solve a lot of issues but it's apparently heavy-weight. We probably don't need that kind of functionality. 

		Combine LamdaTrigger and ObjectTrigger into one class since an Object Trigger can do everything a LambdaTrigger can but more?
		It's really just to make things more clear to readers of the code. If a label has an ObjectTrigger, you can bet that it relies on an object change rather than something in global scope.
3/6/2020:
	All non-templated functions have now been moved to .cpp files for consistency. 

2/28/2020:
	ComponentContainer was almost removed in favor of having Component<T> handle components and their entities. While this implementation can work, every child class of Component will inherit every member of Component, which may create some very large classes. 

2/25/2020:
	There is in fact a use for Component inheriting from ComponentContainer; this ensures that deleting a Component* will call both ~Component and ~ComponentContainer. Not having Component inherit from ComponentContainer will only call ~Component. However, we don't want multiple <Entity,Component> pairs in ComponentContainer<Component> so we allow the ComponentContainer to be passed a pointer. If this pointer is null, we don't add Component to ComponentContainer. Unlike all other components, Component always passes null to ComponentContainer<Component>() ensuring that we don't store anything in ComponentContainer<Component>::components while still inheriting form ComponentContainer<Component>.

2/24/2020:
	ComponentContainer now has unordered maps for better performance.
	Component no longer inherits from ComponentContainer. Component inheriting from ComponentContainer had no benefit and instead caused a bug where removing a component from an entity more than once would cause a crash as an entity can have multiple Components. Removing an entity from ComponentContainer could remove the wrong instance since the ComponentContainer<Component> will have multiple entries for a certain entity if that entity has multiple components. Our component system has the flaw of not allowing entities to have multiple components of the same descendancy and allowing Component to inherit from ComponentContainer is a way of exploiting this flaw since every component inherits from Component. 

2/14/2020:
	Rather than give Chunk a bunch of utility functions, like getUnit(), or addUnit(), Map is now in full control of Chunk. It has all the utility functions, Chunk is now a child class of Map, and, since Chunk is only accessible by Map, Chunk's members are all public now. This decision was made because before, Map would have its own version of Chunk's functions that were exactly idential except that Map would first find the correct chunk. Chunk really doesn't do anything fancy and Map already had direct control over it  so there's no reason to encapsulate it. Just let Map do all the work and Chunk will just be data storage.
	The decision has been made to have Map be the class in charge of removing and adding entities rather than Manager. While it makes sense for Manager to be in charge of everything entity, Map is essentially the entity storage unit; in the same way it makes sense for a vector to be able to erase its own elements, it makes sense for Map to erase its own units.
	Current roles of each class in game.h:
	Manager: entity interactions, entity updating, entity rendering. Also currently manages user input. Basically makes the game run.
	Map: storage class for the chunks. Manages chunks and retrieves them for other classes. Adds and removes entities.
	GameWindow: Master class. Ties everything together by facilitating communication between classes. Renders display.
	Chunk: Stores the entities in each chunk.
	AntManager: Manages player assigned tasks

1/28/2020:
	currentTask was kept as a rawpointer to an ant manager rather than a weak_ptr because it's very easy to keep track of whether or not it is null in the updateAntManagers functions. Keeping it as a raw pointer should be faster since we don't have to call .lock() everytime to access the currentTask.

1/14/2020:
	Today I considered removing the idea that AntManager being a task for a group of ants and instead having the player manually reselect groups of ants. This new approach is probably a bit more intuitive but I'm going to stick with the idea of having a list of AntManager, each controlling one task to make controlling a dedicated group of units easier. Starcraft 2 has this feature in the form of control groups.

1/8/2020:
	ApproachComponent has been changed to no longer be a MoveComponent but rather a vanilla component that requires the user to already have a MoveComponent. Essentially, ApproachComponent "guides" the MoveComponent. While the user hasn't collided with the target yet, ApproachComponent will constantly set the target to be the target unit. If the user has collided, ApproachComponent will set the target to the entity's current center so it stops moving. If there is no targetUnit, ApproachComponent does nothing, allowing the MoveComponent to take over. This was done because of the problem of needing ApproachComponents that operated differently when there is no target. Ants do nothing while there is no target and have a MoveComponent that does nothing. Beetles wander around and uses WanderMove as its MoveComponent. In order to maximize flexibility, ApproachComponent influences an entity's MoveComponent. 
	Why not have each ApproachComponent that needs to do something different inherit from a different MoveComponent? While this problem can be done by inheritance, the ApproachComponent::update() is always the same, except that a different parent function is called. This seems redundant.
Here is some pseudocode for what a child of ApproachComponent's update function looks like:

void ApproachChild::Update()
{
    	<Code unique to this child. Usually unique way of finding a target> 

	if no target:	
		MoveParent::Update()
	if at target:
		stop moving
	else:
		move towards target.
} 
The unique way of finding a target and which parent update to call  is the only code that changes. It doesn't make sense to constantly make new classes just to change a couple lines. Besides, repeating code is usually a bad sign as changing one copy of a line of code will mean that all the copies must be changed. Our solution minimizes code reptition. Here's what the code looks like now:
	
void ApproachChild::Update()
{
	<Code unique to this child>
	ApproachParent::Update()
}
ApproachParent::Update() is the only code that is the same constantly, and even it may change if an ApproachComponent inherits from an ApproachComponent. 
	Another idea is to have MoveComponent inherit from ApproachComponent, but that really doesn't make much sense. An object that can move may not be able to approach but an object that can approach can definitely move. 

1/2/2020:
	ResourceComponent now has all the functionality of ResourceCountComponent and ResourceCountComponent has been deleted. There is simply no reason to have both of these components. ResourceCountComponent not only kept track of the amount of resources like a ResourceComponent but also rendered the amount. Fusing these two classes will standardize things and allow more than just ants to collect resources.


12/19/2019:
	ApproachComponent's setTarget member functions now takes in const references to std::shared_ptr rather than just a reference. This allows us to use std::shared_ptr<Ant> in place of std::shared_ptr<Unit>, since having a const reference allows us to take an r-value, in this case the conversion of std::shared_ptr<Ant> to std::shared_ptr<Unit>.

12/18/2019:
	I considered removing the vector<std::shared_ptr<Component>> components variable in the Entity class because we already have all the components attached to an entity stored in Component Containers. However, searching through every component container would be difficult. I kept the vector to make updating an entity easier.
	Created ApproachComponent, which is a MoveComponent that can move towards a target Unit. It keeps track of this target unit with a weak ptr. It is essentially a more flexible MoveComponent; if the targetUnit pointer is null, this class behaves exactly like a MoveComponent. Why not instead add the functionality directly to MoveComponent? MoveComponent is in components.h, which means that it should work with all entities, whereas ApproachComponent is only supposed to work with Unit. I considered having MoveComponent hold a weak_ptr to a RectComponent but there's currently no way to get a shared_ptr to a component.

12/17/2019:
	AntManager now has an enum that represents all the possible tasks the manager can be currently working on. Currently, they are IDLE, ATTACK, MOVE, and COLLECT. IDLE means the manager is not doing anything at the moment and the ants are just standing around. While it is possible to deduce what the AntManager is currently doing based on the values of various member variables, this solution is a bit cleaner and easier to manage.
	The game now quits if the anthill is destroyed. The way this is done is currently kind of gritty. The Gamewindow has a public boolean variable called quit that represents whether or not the game should quit. The main loop checks the value of this quit value every iteration and quits if it is ever true.

12/8/2019:
	Both Manager::addEntity and Manager::addAnt now return a shared_ptr to the unit/ant added. This allows other classes that also want to share ownership to copy the pointer. So far, this is only used by the anthill class to create a weak_ptr to ants that it owns. 
	Anthill currently directly has a list of std::weak_ptr<Ant> to keep track of what ants are associated with it rather than a component that keeps track of the ants. This may be changed later.
	Anthill now directly creates ants. Pressing the create ant button now instead causes the anthill to create an ant. This is a built-in Anthill feature; Anthill directly does this rather than relying on a component. Feel free to change this. 

12/5/2019:
	Manager's RawQuadTree member variable was changed from a RawQuadTree to a regular QuadTree. This change was reverted because the RawQuadTree keeps track of RectComponents, not the actual units. Since it doesn't own the components, it doesn't make sense to use QuadTree.
	AntManager is now no longer considered to be a singleton class like Manager, but a class that represents all the tasks various groups of ants are working on. One change is that the class now manages a raw pointer to its creating Manager. This is a raw pointer because the pointer is only alive as long as either the Manager is; if the Manager is ever null, the AntManager should also be destroyed. It should be noted that Manager still has a singleton shared_ptr to AntManager. It'll be changed to a vector of AntManagers at a later more convenient time.
	AntManager's targetUnit member variable was changed from a Unit* to a std::weak_ptr<Unit>. A weak_ptr is now used to prevent dangling memory. Since there are now supposed to be multiple instances of AntManager, having a raw pointer to a target unit that is manually handled becomes more expensive, so a weak_ptr makes things easier.-
	AntManager is now a public friend class outside of Manager. There is clearly a lot of variables inside Manager that AntManager wants to access. The question was whether or not to keep AntManager inside Manager and if so, should it be public or private? Private nesting was overturned because other classes may need pointers to AntManager, most notably Ant since each Ant may need to point to its owning AntManager. This may change in the future. Public Nesting was overturned because there's no reason to have public nesting since the only change is that the name of AntManager's member functions in game.cpp are now longer. May as well move AntManager out and make it a friend class to create less typing.
	The spacing variable inside Manager has now been moved to AntManager. Since AntManager is the class that controls ant positioning, the variable makes more since in AntManager.
	Manager now no longer has a master vector of entities, but rather a master map of entities, where the key is the address of the entity. This was primarily done to make accessing entities, particularly when testing collision easier. The RawQuadTree only has raw pointers to the RectComponent within each Unit; if a class, such as say AntManager, wants to maintain a weak_ptr to an entity, it would need to copy the original shared_ptr. This mapping allows one to quickly find collision detection with a RectComponent, then quickly find not only the actual Unit the RectComponent stands for, but also the shared_ptr to copy.
	Having a RawQuadTree of actual Units may make things easier than having a RawQuadTree of RectComponents. This way, the RawQuadTree could become a regular QuadTree and actually own each object, which will make copying into a weak_ptr easier. However, then Unit would have to inherit from either RectPositional or RectComponent. In either case, making Units that have different movement/collision patterns is awkward as that would cause a lot of inheritance from Unit. One point of the component system is to prevent our actual Units from inheriting as changes to the base class (in this case Unit) causes a waterfall of changes. 


	